= CRuby との比較

mruby の CRuby との差異は RiteVM にとどまりません。
ここでは主に筆者が気になった 2 点、 mruby で使用されるハッシュテーブルライブラリ khash と ガベージコレクションについて簡単に触れてみます。

== khash

=== khash の基礎

khash は Hash の実装などで使用される mruby のハッシュテーブルのデータ構造と操作関数のセットです。
khash の特徴として、実装がヘッダ（ include/mruby/khash.h ）で完結し、ほぼすべてマクロで書かれていることが挙げられます。
なお、 khash はゼロから実装されたわけではなく、 @<href>{https://github.com/attractivechaos/klib, klib} を参考に作られているようです。

ちなみに CRuby においてハッシュテーブルは st_table というまた別の構造を用いています。
この点については詳細は 「Rubyソースコード完全解説」@<bib>{rhg} を参照してみていただければ幸いです。

khash によるハッシュテーブルは @<table>{kh} のようなデータ構造を持ちます。
ハッシュテーブルの構造体はマクロで任意の文字列が末尾に付与されて命名されます。

//table[kh][kh ハッシュテーブルの構造]{
名前	内容 
-------------------------------------------------------------
n_buckets	メモリを確保した最大要素数
size	現在使われている（削除済みでない）要素数
n_occupied	一度でも値がセットされたことのある要素数
keys	キー配列
vals	値配列
ed_flags	各要素が空や削除済みかどうかを管理するフラグ配列。(empty&delete flags?)
//}

このデータ構造では @<img>{khash} のような連続したメモリ領域を使用します。
図にある通り、各キーと値のペアが空あるいは削除済みかどうかを管理する ed_flags は n_buckets の 1/4 のサイズとなります。
これは空、削除済みの表現を 2 ビットで表すため、 8 ビット中に 4 要素のフラグを収めることができるためです。

//image[khash][khash のデータ表現（図中の K はキー、 V は値）]

khash ですが、主に @<table>{khash} のような操作をサポートしています。
kh_init で初期化、 kh_begin と kh_end でイテレーション、 kh_get と kh_put でキーによる操作、 kh_key と kh_val で要素の参照、 kh_destroy で終了処理というのが基本的な操作かと思われます。

//tsize[30,90]
//table[khash][khash の操作関数]{
名前	内容 
-------------------------------------------------------------
kh_init_size	サイズを明示してハッシュテーブルを初期化する
kh_destroy	ハッシュテーブルを破棄してメモリを解放する
kh_clear	全要素をクリアする（空フラグを立てる）
kh_resize	指定の領域が格納できるようメモリを確保し直す。元の要素は引き継ぐ
kh_put	ハッシュテーブルにキーをセットする
kh_put2	ハッシュテーブルにキーをセットする。 kh_put と異なり第 5 引数に既にキーが存在したか、削除済み領域を再利用したか、それとも空の領域にセットしたかの結果を受け取れる
kh_get	指定のキーに対応するハッシュテーブル中の要素のインデックスを返す
kh_del	指定のインデックスに対応するハッシュテーブル中の要素の削除フラグを立てる
kh_key	指定のインデックスに対応する keys の要素を返す
kh_val	指定のインデックスに対応する vals の要素を返す
kh_begin	ハッシュテーブルの先頭要素のインデックスを返す
kh_end	ハッシュテーブルの末尾要素のインデックスを返す
//}

これらのデータ構造と操作関数を使用するには宣言、定義を行うためのマクロ KHASH_DECLARE と KHASH_DEFINE を呼び出しておく必要があります。

なお、 khash ではハッシュ関数は KHASH_DEFINE を呼び出す際に指定することになります。
khash のヘッダで kh_int_hash_func() と kh_int64_hash_func() 、 kh_str_hash_func() の三種類が定義されるので、これを用いても良いです。
またハッシュ値の衝突を検出するための比較関数も KHASH_DEFINE を呼び出す際に指定する必要があります。
比較関数は kh_get と kh_put で用いられ、もし衝突を見つけた際はインデックスをインクリメントしていき空き要素を線形探索します。

=== Hash への適用

折角なので mruby の Hash の実装にどのように khash が用いられているかも見てみましょう。
ソースコードは src/hash.c となります。

まず Hash における khash の宣言と定義ですが、キーと値の型はそれぞれ mrb_value と mrb_hash_value となります。
ハッシュ関数と比較関数も mrb_hash_ht_hash_func() と mrb_hash_ht_hash_equal() という Hash の実装専用の関数を指定しています。
これらの関数には、キーの mrb_value 型変数を型ごとにハッシュ値計算、比較するようなロジックが含まれています。

mruby の Hash のメソッドは khash のハッシュテーブルにオブジェクトヘッダや管理情報用テーブルを含めた RHash 構造体への操作として実装されています。
例えば initialize は大枠で言えば kh_init を呼び出す形でハッシュテーブルの初期化を実現しています。
また [] では kh_get() によるキーの探索を行い kh_val() で値を返却、 []= では kh_put2() でキーをセットした後 kh_val() で値を代入します。


== ガベージコレクション

「mruby のすべて」@<bib>{mruby_book} という書籍では全 5 章のうち 1 章まるまるガベージコレクション（以下、 GC）の話題に割いています。
その事実からも mruby の GC が重要な話題であることが分かり、 CRuby と比較する上でもぜひ触れておきたい話を言えるでしょう。

本書では GC の戦略や設計の詳細までは解説しません。
その点は既に存在するその書籍を読んで補完していただければ幸いです。

=== mruby の GC の基礎

mruby ではいわゆるマークスイープ方式の GC を行っています。
すなわちルートオブジェクトから、オブジェクトの参照関係を辿って到達できたオブジェクトをマークし、マークがついていないオブジェクトは死んでいるとみなして回収することで GC を実現します。

ただし単純にマークスイープするのではなく組み込み機器への適用を見越して、一回の GC サイクルで全てを行わずに段階的にサイクルを実行するインクリメンタル GC 採用しています。
mruby のインクリメンタル GC ではマークスイープを 3 つのフェーズ、 GC のルートオブジェクトを検出するルートスキャンフェーズ、生きていると思われるオブジェクトをマークするマークフェーズ、マークされていないオブジェクトを死んでいるとみなし回収するスイープフェーズに分割して実行します。

また、オブジェクトの世代を若い世代と長命な世代に分けて若い世代だけ頻繁に GC することでオーバーヘッドを減らす世代別 GC を採用しています。
世代別 GC は複数世代を設けることができますが、 mruby としては 2 世代、若い世代と古い世代で管理されます。
具体的には GC を 1 サイクル生き残ったオブジェクトは古い世代として扱われるようになります。
mruby の世代別 GC では若い世代のみ対象にするマイナー GC 、全世代を対象にするメジャー GC の二種類に分類されます。

=== GC に関するオブジェクトの状態

mruby では各オブジェクトに「色」の情報を持たせ、色が何になっているかによってオブジェクトの生死や世代を管理します。
具体的には白、灰色、黒という三色で管理されます。

これは「ガベージコレクション本」@<bib>{gc_book} に記載されている三色抽象化 (tricolour abstraction) に近いものがあります。
これに加えて mruby はインクリメンタル GC をするので GC のサイクルの途中に新たなオブジェクトが生成され、すぐに回収して良いか判断がつかない場合があります。
この問題のため、 mruby では白色についてさらに 2 つの状態を用意してすぐに回収できるかを分類可能にしています。
（白色の 2 状態は White-A と White-B という名前が付けられていて、 GC サイクルごとに意味するところが入れ替わります。
本書では記述のシンプル化のために意味が固定されているような記述をしていますが、適宜脳内補完していただけると幸いです）


これらの状態とそれが指すオブジェクトの状態は @<table>{gc_color} の通りになります。
ちなみに mruby の実装としては、これらの色情報は 3 ビットで表現されます。

//tsize[30,80]
//table[gc_color][GC の色情報]{
色種別	内容 
-------------------------------------------------------------
White-A	GC のサイクルの途中に生成されたオブジェクト。その GC サイクルではスイープの対象にならない
White-B	死んでいるとみなされるオブジェクト。その GC サイクルでスイープの対象になる
Gray	生きているとみなされるオブジェクト。ただしそのオブジェクトの子オブジェクトは生きているか分からない。マークフェーズの途中で生じる状態
Black	生きているとみなされるオブジェクト。そのオブジェクトの子オブジェクトを含めて生きている
//}

これらの色によって表現される状態の遷移図は @<img>{gc_tricolour} の様になります。

//image[gc_tricolour][三色の色情報の状態遷移]

=== アリーナ

mruby の GC において他にややこしい点として、しばしば C で mrbgem が実装されることが挙げられます。
なにがややこしいかというと、 C の関数を実行中に生成された mruby のオブジェクトを回収対象にして良いのか判断がつかないのです。
mruby ではこの問題への対応のため、アリーナという概念を導入しています。

アリーナは GC においてルートオブジェクトとして扱うオブジェクトを羅列した配列です。
C 関数から生成したオブジェクトは自動的にこのアリーナに含められ、関数実行中はルートオブジェクトとして扱われるようになります。
また C 関数から明示的にアリーナによる GC の対象を制御する際は、インデックス操作を行うことでルートオブジェクトから外れるようにできます。
このテクニックは特に C で mrbgem を実装して、その中でループでオブジェクトを生成しまくる時などに気をつける必要のある点だったりします。

=== ライトバリア

インクリメンタル GC の導入のために mruby ではマークフェーズの途中にオブジェクトの参照関係が書き換わる可能性があります。
起こりうる重大な問題として「回収されてはいけないオブジェクトが、マークフェーズ中に関連づいたためマークされず回収されてしまった」シナリオが考えられます。

mruby ではこの問題に対処するため、オブジェクトの関係に関する書き込みがあった場合にマークをし直すというポリシーの元ライトバリアを導入しています。
具体的には @<img>{gc_writebarrier} に示すように、オブジェクト A と、そこから参照されるオブジェクト B がある時にどちらを主体にするかによる 2 種類のライトバリアが提供されています。

//image[gc_writebarrier][ライトバリアの概念]

=== GC の実装

mruby の GC の実装は src/gc.c にあります。
また構造体や関数の宣言が include/mruby/gc.h にあります。

==== GC 周りの基本データ構造

GC に関する情報を表現する mrb_gc のデータ構造は @<table>{mrb_gc} のようになっています。
mrb_gc のデータは mrb_state のメンバとして管理されます。

//tsize[40,80]
//table[mrb_gc][mrb_gc の構造]{
名前	内容 
-------------------------------------------------------------
heaps	mruby で管理されるヒープページのリスト
sweeps	マークフェーズの結果、スイープのターゲットとなったヒープページのリスト
free_heaps	空き領域のヒープページのリスト
live	生きているオブジェクトの数
arena, arena_capa, arena_idx	アリーナ領域配列とその容量、インデックス
state	GC が今どのフェーズにいるのかを示す状態変数
current_white_part	新たに生成するオブジェクトを White-A か White-B かどちらで塗るべきかを示す変数
gray_list	マークフェーズで処理の途中の、 Gray にマークされたオブジェクトのリスト
atomic_gray_list	マークフェーズの最後に割り込み無しにマークされることを保証すべきオブジェクトのリスト
live_after_mark	マークフェーズの最後に、生きているとみなされる(black な)オブジェクトの数
threshold	インクリメンタル GC 実行タイミングを図るためのしきい値
interval_ratio	threshold の計算に用いる係数。 live が threshold を超えたときにインクリメンタル GC が実行される
step_ratio	インクリメンタル GC の 1 ステップでどのくらい処理を進めるかの計算に用いる係数
majorgc_old_threshold	メジャー GC 実行タイミングを図るためのしきい値
//}

==== GC の実行タイミング

GC の実装のエントリポイントは mrb_incremental_gc() になります。
この関数は mrb_obj_alloc() でオブジェクトに新しくヒープの空き領域を割り当てる際に、生きているオブジェクトの数 live がしきい値 threshold を超えた場合に呼び出されます。
mrb_obj_alloc() でオブジェクトのために割り当てた領域は free_heaps のフリーリストから外され、またそれによってフリーリストの要素が空になったらそのヒープページを free_heaps から外します。

mrb_incremental_gc() を呼び出した後、どのようなタイミングでどのような GC を実行するかを図示したものが @<img>{gc_flow} です。

//image[gc_flow][GC の実行フロー][scale=0.7]

mrb_incremental_gc() はフェーズ毎 GC 処理を 2 個の関数、メジャー GC 実行時は incremental_gc_step() 、マイナー GC 実行時は incremental_gc_until() を呼び出すことで実行します。
incremental_gc_step() はマークフェーズではマークしたオブジェクト数、スイープフェーズでは解放したオブジェクト数が上限を超えたら一旦リターンします。
この上限は step_ratio を係数にして算出した値が使用されます。
incremental_gc_until() は指定の状態、 mrb_incremental_gc() から呼び出す際は次のルートスキャンフェーズまでリターンせずに GC を実行します。

mrb_incremental_gc() はもうひとつ、古い世代のオブジェクトが多くなりすぎた際に再び GC の対象にする仕事もしています。
これは mrb_incremental_gc() のリターン直前に live が majorgc_old_threshold を超えた場合、全てのオブジェクトを clear_all_old() を介して白でマークし直すことで実現します。

==== mrb_incremental_gc() のさらに先

前節で出てきた incremental_gc_step() や incremental_gc_until() では具体的な GC 処理を incremental_gc() を更に呼び出すことで進行します。
incremental_gc() は現在の GC 実行状態が前述の 3 つのフェーズのどれに属するかを判別して、個別の処理を行なう関数を呼び出します。
具体的にはルートスキャンフェーズでは root_scan_phase() 、マークフェーズでは incremental_marking_phase() 、スイープフェーズでは incremental_sweep_phase() を呼び出します。

root_scan_phase() ではルートオブジェクト、具体的にはグローバル変数やアリーナに格納されたオブジェクト、 mrb->object_class などを mrb_gc_mark() を介してマークします。
mrb_gc_mark() は内部的には add_gray_list() を呼び出してオブジェクトを Gray でマークしつつ gray_list に追加します。
ちなみに mrb_gc_mark() は White なオブジェクトに対してのみ add_gray_list() を呼び出します。
これによって既にマークされた古い世代のオブジェクトをマークフェーズの対象としなくする世代別 GC を実現しています。

incremental_marking_phase() は gray_list の要素がなくなるまで gc_gray_mark() に渡します。
gc_gray_mark() は大きく分けて gray_list から取り出したオブジェクトの子オブジェクトを辿ってマークする（と同時に親オブジェクトは Black にマークされる）のと、それによってマークされたオブジェクト数を返す 2 つの仕事をしています。
前者では gc_mark_children() を呼び出し、型によって更に詳細なマークロジックを持つ関数を呼び出すことで実現します。
後者はマークフェーズがどれだけ進み、中断してリターンするかどうかの判断材料に使われます。

incremental_sweep_phase() はヒープページのオブジェクトがマークされているかを順番にチェックしていき、マークされていないオブジェクトを解放していきます。
オブジェクトの解放は obj_free() を呼び出し、型ごとに解放関数を呼ぶことで実施します。
その後解放されたヒープページは mrb_free() を呼び出すか未使用のヒープページのリストに追加してその後のオブジェクトへの割り当てに再利用するかします。
ちなみに incremental_sweep_phase() ではチェックしたヒープページのサイズを中断してリターンするかどうかの判断材料に使います。

==== ライトバリアの実装

前述の通りライトバリアには 2 種類、オブジェクト A とそこから参照されるオブジェクト B がある時、オブジェクト A から参照されるオブジェクトをマークするライトバリアと、オブジェクト B をマークするライトバリアがあります。
前者が mrb_field_write_barrier() 、後者が mrb_write_barrier() です。

mrb_field_write_barrier() の実装はシンプルで、オブジェクト B に対して add_gray_list() を呼び出します。
これによりオブジェクト B はマークフェーズにおけるマーク処理の対象になり、スイープフェーズを生き残ることができます。

mrb_write_barrier() は atomic_gray_list にオブジェクト A を追加します。
atomic_gray_list はその名の通りアトミックな gray_list で、マークフェーズからスイープフェーズに移行する前に呼び出される final_marking_phase() でマーク処理の対象になります。
final_marking_phase() 実行中は中断してリターンされることはなく、辿ることができる子オブジェクトも無事マークされスイープフェーズを生き残ることができるようになります。

==== アリーナの実装

アリーナを示すデータですが、 mrb_gc の arena がアリーナ配列、 arena_idx がルートオブジェクトとして扱うべきインデックス、 arena_capa がアリーナの容量となります。
それぞれの関係は @<img>{arena} のようになります。

//image[arena][アリーナ領域]

root_scan_phase() において arena_idx より低い番地に格納されるオブジェクトは、  mrb_gc_mark() に渡されマークされます。
arena_idx は C の関数から操作可能でして、 mrb_gc_arena_save() でその時の arena_idx の取得、 mrb_gc_arena_restore() で arena_idx の再設定が可能です。
また、 gc_protect() を呼び出すことでオブジェクトをアリーナで管理するように操作することもできます。

