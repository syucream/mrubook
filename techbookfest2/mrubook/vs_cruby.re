= CRuby との比較

mruby の CRuby との差異は RiteVM にとどまりません。
ここでは主に、 mruby で使用されるハッシュ関数ライブラリ khash と ガベージコレクションについて簡単に触れてみます。

== khash

=== khash の基礎

khash は Hash の実装などで使用される mruby のハッシュテーブルのデータ構造と操作関数のセットです。
khash の大きな特徴として、実装がヘッダで完結し、ほぼすべてマクロで書かれていることが挙げられます。
ちなみに khash はゼロから実装されたわけではなく、 @<href>{https://github.com/attractivechaos/klib, klib} を参考に作られています。
また、 CRuby においては st_table というまた別のハッシュテーブルを用いています。
この点については、やはり 「Rubyソースコード完全解説」@<bib>{rhg} を参照してみていただければ幸いです。

khash によるハッシュテーブルは下記のようなデータ構造を持ちます。
ちなみにハッシュテーブルの構造体はマクロで任意の文字列が末尾に付与されて命名されます。

//table[kh][kh ハッシュテーブルの構造]{
名前	内容 
-------------------------------------------------------------
n_buckets	メモリを確保した最大要素数
size	現在使われている（削除済みでない）要素数
n_occupied	一度でも値がセットされたことのある要素数
keys	キー配列
vals	値配列
ed_flags	各要素が空や削除済みかどうかを管理するフラグ配列。(empty delete flags?)
//}

khash ですが、下記のような操作をサポートしています。
kh_init で初期化、 kh_begin と kh_end でイテレーション、 kh_get と kh_put でキーによる操作、 kh_keys と kh_val で要素の参照、 kh_destroy で終了処理というのが基本的な操作かと思われます。

//table[khash][khash の操作関数]{
名前	内容 
-------------------------------------------------------------
kh_init_size	サイズを明示してハッシュテーブルを初期化する
kh_init	サイズを明示せず、デフォルト値（32）でハッシュテーブルを初期化する
kh_destroy	ハッシュテーブルを破棄してメモリを解放する
kh_clear	全要素をクリアする（空フラグを立てる）
kh_resize	指定の領域が格納できるようメモリを確保し直す。元の要素は引き継ぐ
kh_put	ハッシュテーブルにキーをセットする
kh_put2	ハッシュテーブルにキーをセットする。 kh_put と異なり第 5 引数に既にキーが存在したか、削除済み領域を再利用するか、それとも空の領域にセットするかの結果を受け取れる
kh_get	指定のキーに対応するハッシュテーブル中の要素のインデックスを返す
kh_del	指定のインデックスに対応するハッシュテーブル中の要素の削除フラグを立てる
kh_copy	別のハッシュテーブルに要素をコピーする
kh_exist	指定のインデックスに対応する要素が空でも削除でもない場合 true を返す
kh_key	指定のインデックスに対応する keys の要素を返す
kh_val	指定のインデックスに対応する vals の要素を返す
kh_value	kh_val のエイリアス
kh_begin	ハッシュテーブルの先頭要素のインデックスを返す
kh_end	ハッシュテーブルの末尾要素のインデックスを返す
kh_size	ハッシュテーブルの size を返す
kh_n_bucket	ハッシュテーブルの n_buckets を返す
//}

これらのデータ構造と操作関数を使用するには宣言、定義を行うためのマクロ KHASH_DECLARE と KHASH_DEFINE を呼び出しておく必要があります。

なお、 khash ではハッシュ関数は KHASH_DEFINE を呼び出す際に自分で指定することになります。
khash のヘッダで kh_int_hash_func() と kh_int64_hash_func() 、 kh_str_hash_func() の三種類が定義されるので、これを用いても良いです。
またハッシュ値の衝突を検出するための比較関数も KHASH_DEFINE を呼び出す際に指定する必要があります。
比較関数は kh_get と kh_put で用いられ、もし衝突を見つけた際はインデックスをインクリメントしていき空き要素を線形探索します。

=== Hash への適用

折角なので mruby の Hash の実装にどのように khash が用いられているかも見てみましょう。
ソースコードは src/hash.c となります。

まず Hash における khash の宣言と定義ですが、キーと値の型はそれぞれ mrb_value と mrb_hash_value となります。
ハッシュ関数と比較関数も mrb_hash_ht_hash_func() と mrb_hash_ht_hash_equal() という Hash の実装専用の関数を指定しています。
これらの関数には、キーの mrb_value 型変数を型ごとにハッシュ値計算、比較するようなロジックが含まれています。

mruby の Hash のメソッドは khash のハッシュテーブルにオブジェクトヘッダや管理情報用テーブルを含めた RHash 構造体への操作として実装されています。
例えば initialize は大枠で言えば kh_init を呼び出す形でハッシュテーブルの初期化を実現しています。
また [] では kh_get() によるキーの探索を行い kh_value() で値を返却、 []= では kh_put2() でキーをセットした後 kh_value() で値を代入します。


== ガベージコレクション

