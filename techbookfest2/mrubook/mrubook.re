= はじめに

本書は主に Rubyist をターゲットに、軽量 Ruby 実装である mruby の言語処理系の実装を解説していきます。

想定する読者としては Ruby でコードを書いたことがある人、 Ruby の言語処理系に興味がある人としています。
そのため本書では Ruby の文法についていちから説明するなどといった記述はしません。あらかじめご了承ください。

筆者の目指す本書のゴールとしては、 mruby の特徴やその実装に関する造詣を深めていただき、 mruby に対する興味を深めていただいたり、もっと欲を言うと mruby コミュニティに参加していただくきっかけになることとしています。
本書が、あなたにとって mruby という新しい世界に踏み込むきっかけになれたら嬉しいです。

== mruby とは

さっそく mruby の実装の話に突入したいところですが、流石に急すぎると思われるので一旦簡単に mruby 自体について解説いたします。
あなたが「mruby は既にある程度知ってるよ！」という方でしたら、次の章までスキップしていただければ幸いです。

mruby は先述の通り軽量、省メモリ Ruby の実装です。
また機能もある程度 Ruby から削減されています。具体的には Ruby の JIS/ISO 規格に記載がある機能は標準で搭載されているのですが、それ以外はオプションな立ち位置で組み込むが ON/OFF が可能だったり、そもそも実装されていなかったりします。

主な用途としては組み込み環境向けでの利用が想定されます。
また他のアプリケーションに組み込んで使用するパターン（例えば、 matsumoto-r さんが開発した mod_mruby や ngx_mruby など）や、コマンドラインツールを実装するための言語として使用（mruby-cli）されていたりもします。

さらに mruby のサードパーティライブラリは mrbgem という単位で管理・配布可能です。ちょうど Ruby の RubyGems に相当します。
mrbgem は mruby をビルドする際の設定ファイルにそれを利用する記述することで、ビルドされたバイナリにリンクされる形で取り込まれます。


= 言語処理系のコア

では mruby の実装の話に入っていきましょう。まず触れるのは、 mruby を mruby たらんとさせている言語処理系の話から初めます。

== 中間表現

mruby の VM が解釈する中間表現のコードは mruby としては iseq(instruction sequence) と呼ばれます。
これはソースコード上は mrb_code という uint32_t 型の別名として表現されています。

また iseq にシンボル情報などを付与したものは irep (internal representation) という名前で呼ばれています。

言語処理系のコンパイラや VM の実装を読む前に、まずはこの irep の中身を探索してみましょう。

=== irep (internal representation)

irep は include/mruby/irep.h で定義される、 mruby のコードの実行に必要な情報を保持する基本的なデータ構造です。
大きく分けて、実行するコード自体のデータ iseq 、ローカル変数やプールなどの情報、ソースコードのファイル名などのデバック情報を含みます。
詳細は下記に示すとおりです。

//table[irep][irep の構造]{
名前	内容 
-------------------------------------------------------------
nlocals	ローカル変数の個数
nregs	レジスタの個数
flags	irep の解釈の仕方を制御するためのフラグ
iseq	コードセグメントの先頭番地へのポインタ。実体としては 32 ビット整数値(mrb_code) のポインタ
pool	TODO
syms	mrb_sym の配列
reps	続きの？ mrb_irep のリスト
lv	ローカル変数配列。実体としてはシンボルと符号なし整数値のペアの配列
各種カウンタ	TODO
//}

=== RProc

mruby の Proc オブジェクト型です。
mruby ではコンパイラがこのオブジェクトを生成し、 VM が実行することで mruby で処理を行う形になります。

RProc のデータ構造は下記の通りになります。

 * 具体的な処理の本体
 ** これは irep もしくは mrb_state と mrb_value を引数に取り mrb_value を返す関数ポインタのどちらかになります
 * REnv
 * ターゲットクラス

== mruby コンパイラ

では実際に mruby のソースコードを読みながら処理を追ってみます。
mruby における字句解析、構文解析、 iseq 生成部分は mrbgems/mruby-compiler/ に存在します。
mruby のコンパイラの仕事は mruby のスクリプトを解釈して、 mruby の VM が実行可能な iseq を出力することにあります。

iseq を得るまでの全体の流れは下記の通りになります。
* なんか全体の流れがわかるいい感じの図

まず mruby の字句解析ですが、スキャナ(字句解析器)は parse.y の parse_yylex() が該当します。
parse_yylex() は基本的にソースコードを少しずつ読みつつトークンを得ていくのですが、キーワードの検出については lex.def で定義される mrb_reserved_word() を呼んでいます。
これはゼロから実装されている訳ではなく、keywords に定義されている mruby のキーワードを検出するために GNU Perfect(gperf) で生成した完全ハッシュ関数を利用しています。
この実装方法は CRuby でも同じだったりします。「Rubyソースコード完全解説」@<bib>{rhg} という書籍に詳細が掲載されていますので、詳しく知りたい方はそちらも合わせてご参照ください。

* 構文解析〜〜
* parser_state について解説 parse.y にある

コード生成を行っているのは codegen.c となります。
このソースコードにおいて読解のエントリポイントとなるのは mrb_generate_code() でしょう。
この関数は mrb_state 変数と parser_state 変数を取ってコード生成を行い、その結果を RProc の形式で返却します。
mrb_generate_code() を正常系に絞って追っていきますと、大筋としては codegen() で irep の生成を行い、それを用いて mrb_proc_new() で RProc オブジェクトを生成しているのが分かります。

codegen() は再帰呼び出しすることで構文木を辿り、ノード毎にコード生成を行い、 iseq の末尾に追加していきます。
mrb_generate_code() は自身に渡された parser_state から AST のルートノードへのポインタを取り出して codegen() を呼び出す際に渡します。

== Rite VM

mruby の一番の特徴は、 mruby の VM (RiteVM) にあるとも考えられるでしょう。
RiteVM についてつらつらと書いていきます。

=== アーキテクチャ

RiteVM の実装を読み解く上で命令セットアーキテクチャの理解は不可欠です。
というわけで、まずは mruby の命令について理解を深めてみましょう。
なお、ソースコード上は include/mruby/opcode.h がこの内容に該当します。

RiteVM はレジスタマシンとして動作します。
1 つの命令は 32 ビットで表現され、オペコードと 0 個以上 3 個以上のオペランドを取る形式になり、下記のようなバリエーションが存在します。

//table[regs][レジスタ種別]{
名前	内容 
-------------------------------------------------------------
A	9 ビット長のレジスタ
Ax	25 ビット長のレジスタ
B	9 ビット長のレジスタ
Bx	16 ビット長のレジスタ
sBx	16 ビット長のレジスタ(符号付き)
C	7 ビット長のレジスタ
//}

mruby のオペコードの詳細については後述する RiteVM についての節で触れようと思います。
ここではオペコードのおおまかな種類のみ列挙します

//table[opcodes][命令種別]{
カテゴリ	命令の例
-------------------------------------------------------------
ロード系	MOVE, LOADL, LOADI
変数操作系	GETGLOBAL, SETGLOBAL, GETIV, SETIV
制御系	JMP, CALL, RETURN
演算系	ADD, SUB, EQ, LT
配列操作系	ARRAY, ARYCAT
文字列操作系	STRING, STRCAT
オブジェクト操作系	OCLASS, CLASS, MODULE
特殊系系	NOP, DEBUG, STOP
//}


=== VM の状態を示すデータ構造 mrb_state 

mrb_state は VM の実行状態情報を保持するデータ構造です。下記のような情報を保持します。

 * 各基本クラスへのポインタ
 * GC 情報
 * グローバル変数テーブル
 * シンボルテーブル
 * mrb_context (RiteVM の実行コンテキスト, 後述)
 * exc
 ** 例外ハンドラへのポインタ

=== 実行コンテキスト mrb_context

mrb_context は VM の実行コンテキストを保持するデータ構造です。下記のような情報を保持します。

//table[mrb_context][mrb_context の構造]{
メンバ名	意味
-------------------------------------------------------------
prev	以前のコンテキスト。例えば Fiber における親 fiber
stack, stbase, stend	RiteVM のスタック情報
ci, cibase, cind	メソッド呼び出し情報
rescue, rsize	rescue ハンドラに関する情報
ensure, esize	ensure ハンドラに関する情報
status, fib	そのコンテキストの持ち主の fiber の実行状態とその fiber へのポインタ
//}

RiteVM はレジスタマシンであるという話をしましたが、このレジスタはスタック上に保持されています。

=== メソッド呼び出し情報 mrb_callinfo

mrb_context は mruby のメソッド呼び出しに関わるデータ構造です。下記のような情報を保持します。

//table[mrb_callinfo][mrb_callinfo の構造]{
メンバ名	意味
-------------------------------------------------------------
proc	呼び出されたメソッドの Proc オブジェクト
nregs	レジスタ数
ridx, eidx	rescue, ensure 呼び出しのネストの深さ
env	？？？
//}


=== VM のエントリポイント

それでは実際に VM の実装を見ていきましょう。
まずは include/mruby.h で宣言されている、ユーザが目にする関数を足がかりに処理を追っていきます。

これらのエントリポイントとなる関数としては下記が挙げられます。

 * mrb_run()
 * mrb_toplevel_run_keep()
 * mrb_toplevel_run()

この 3 つの関数は、 mrb_state と RProc をとり VM の実行を開始します。
複雑な処理はしておらず、メインの処理は mrb_context_run() に任せているように見えます。
というわけで次は mrb_context_run() を覗いてみましょう。

=== VM のメイン処理

前述の mrb_context_run() は mruby の VM のメイン処理です。
見慣れないマクロと多い行数でギョッとするかも知れませんが、行っていることはかなりシンプルです。
処理のフローとしては 1) INIT_DISPATCH マクロでオペコードをフェッチ 2) switch 文でオペコードを判別 3) 命令の実行 を for 文でループしています。

ここではオペコードの一部の実装についてのみ触れていきます。

ロード系命令ではレジスタ間の値のコピーを行ったり、レジスタに任意の値をセットしたりします。
これらの実装としてはシンプルです。
例えば MOVE 命令は mrb_context の stack メンバから得たレジスタを対象にレジスタ間の値のコピーを行います。

変数操作系命令では基本的に 2 つのレジスタを取ります。
GET 操作では取得対象の変数名をレジスタから取得してシンボルを得て、値を GET するための関数を呼び出し、その結果をもう一方のレジスタに格納します。
SET 操作では値をレジスタから値を、 SET 先のシンボルをもう一方のレジスタから得て SET するための関数を呼び出します。
GET/SET するための関数は操作対象の変数の性質によって異なります。
具体的には、グローバル変数であれば mrb_gv_get / mrb_gv_set, 特異変数であれば mrb_vm_special_get / mrb_vm_special_set, インスタンス変数であれば mrb_vm_iv_get / mrb_vm_iv_set, クラス変数であれば mrb_vm_cv_get / mrb_vm_cv_set, 定数であれば mrb_vm_const_get / mrb_vm_const_set になります。
モジュールの定数を GET/SET する場合は mrb_const_get / mrb_const_set を使います。
TODO OP_GETUPVAR / OP_SETUPVAR は何者？

制御系命令ではジャンプをしたり例外処理をしたり、メソッド呼び出しをします。
まず無条件でジャンプする JMP 命令があります。これは 1 オペランド取り、これに指定された値をプログラムカウンタ(実体は iseq へのポインタ)に設定して次サイクルに移ります。
JMPIF と JMPNOT は条件付きの JMP 命令です。 JMP に加えてもう 1 つオペランドを取り、これの評価結果が true かどうかでジャンプするか分岐します。
例外処理についても見ていきましょう。簡単に分類すると raise に関する命令、 rescure に関する命令、 ensure に関する命令になります。
ONERR 命令は例外発生時に処理すべき rescue ブロックを、プログラムカウンタと sBx から算出し、現在の実行コンテキストに追加します。
RESCUE 命令は mrb_state のメンバ exc の値を A が示すレジスタに格納して exc をゼロ初期化します。
POPERR 命令は rescue ブロックの ridx を A から読み出した数の分だけ減らします。
RAISE 命令は A が示すレジスタからオブジェクトを得て mrb_state のメンバ exc に格納し、 raise 処理します。 TODO
EPUSH 命令は ensure 用の ONERR 命令のようなものです。 Bx に指定されたレジスタ番目の irep 要素から proc オブジェクトを得て、現在の実行コンテキストに追加します。
EPOP 命令は ensure 用の POPERR 命令のようなものです。 A に指定されたレジスタの値分だけ ensure の proc オブジェクトを取り出して処理します。

...



= Ruby との比較

== クラスとオブジェクト

== 変数と定数

== khash

== ガベージコレクション

= 標準ライブラリ

= おわりに

